// Generated by the Protocol Buffers 3.0 compiler.  DO NOT EDIT!
// Source file "cast_channel.proto"
// Syntax "Proto2"

import Foundation
import ProtocolBuffers


public struct Extensions { public struct Api { public struct CastChannel { }}}

public extension Extensions.Api.CastChannel {
  public struct CastChannelRoot {
    public static let `default` = CastChannelRoot()
    public var extensionRegistry:ExtensionRegistry

    init() {
      extensionRegistry = ExtensionRegistry()
      registerAllExtensions(registry: extensionRegistry)
    }
    public func registerAllExtensions(registry: ExtensionRegistry) {
    }
  }

  final public class CastMessage : GeneratedMessage {

    public static func == (lhs: Extensions.Api.CastChannel.CastMessage, rhs: Extensions.Api.CastChannel.CastMessage) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasProtocolVersion == rhs.hasProtocolVersion) && (!lhs.hasProtocolVersion || lhs.protocolVersion == rhs.protocolVersion)
      fieldCheck = fieldCheck && (lhs.hasSourceId == rhs.hasSourceId) && (!lhs.hasSourceId || lhs.sourceId == rhs.sourceId)
      fieldCheck = fieldCheck && (lhs.hasDestinationId == rhs.hasDestinationId) && (!lhs.hasDestinationId || lhs.destinationId == rhs.destinationId)
      fieldCheck = fieldCheck && (lhs.hasNamespace == rhs.hasNamespace) && (!lhs.hasNamespace || lhs.namespace == rhs.namespace)
      fieldCheck = fieldCheck && (lhs.hasPayloadType == rhs.hasPayloadType) && (!lhs.hasPayloadType || lhs.payloadType == rhs.payloadType)
      fieldCheck = fieldCheck && (lhs.hasPayloadUtf8 == rhs.hasPayloadUtf8) && (!lhs.hasPayloadUtf8 || lhs.payloadUtf8 == rhs.payloadUtf8)
      fieldCheck = fieldCheck && (lhs.hasPayloadBinary == rhs.hasPayloadBinary) && (!lhs.hasPayloadBinary || lhs.payloadBinary == rhs.payloadBinary)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      // Always pass a version of the protocol for future compatibility
      // requirements.
      public enum ProtocolVersion:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case castv210 = 0
        public func toString() -> String {
          switch self {
          case .castv210: return "CASTV2_1_0"
          }
        }
        public static func fromString(str:String) throws -> Extensions.Api.CastChannel.CastMessage.ProtocolVersion {
          switch str {
          case "CASTV2_1_0":  return .castv210
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .castv210: return ".castv210"
          }
        }
      }

      //Enum type declaration end 



      //Enum type declaration start 

      // What type of data do we have in this message.
      public enum PayloadType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case `String` = 0
        case binary = 1
        public func toString() -> String {
          switch self {
          case .`String`: return "STRING"
          case .binary: return "BINARY"
          }
        }
        public static func fromString(str:String) throws -> Extensions.Api.CastChannel.CastMessage.PayloadType {
          switch str {
          case "STRING":  return .`String`
          case "BINARY":  return .binary
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .`String`: return ".`String`"
          case .binary: return ".binary"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var protocolVersion:Extensions.Api.CastChannel.CastMessage.ProtocolVersion = Extensions.Api.CastChannel.CastMessage.ProtocolVersion.castv210
    public fileprivate(set) var hasProtocolVersion:Bool = false
    // source and destination ids identify the origin and destination of the
    // message.  They are used to route messages between endpoints that share a
    // device-to-device channel.
    // For messages between applications:
    //   - The sender application id is a unique identifier generated on behalf of
    //     the sender application.
    //   - The receiver id is always the the session id for the application.
    // For messages to or from the sender or receiver platform, the special ids
    // 'sender-0' and 'receiver-0' can be used.
    // 
    // For messages intended for all endpoints using a given channel, the
    // wildcard destination_id '*' can be used.
    public fileprivate(set) var sourceId:String = ""
    public fileprivate(set) var hasSourceId:Bool = false

    public fileprivate(set) var destinationId:String = ""
    public fileprivate(set) var hasDestinationId:Bool = false

    // This is the core multiplexing key.  All messages are sent on a namespace
    // and endpoints sharing a channel listen on one or more namespaces.  The
    // namespace defines the protocol and semantics of the message.
    public fileprivate(set) var namespace:String = ""
    public fileprivate(set) var hasNamespace:Bool = false

    public fileprivate(set) var payloadType:Extensions.Api.CastChannel.CastMessage.PayloadType = Extensions.Api.CastChannel.CastMessage.PayloadType.`String`
    public fileprivate(set) var hasPayloadType:Bool = false
    // Depending on payload_type, exactly one of the following optional fields
    // will always be set.
    public fileprivate(set) var payloadUtf8:String = ""
    public fileprivate(set) var hasPayloadUtf8:Bool = false

    public fileprivate(set) var payloadBinary:Data = Data()
    public fileprivate(set) var hasPayloadBinary:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if !hasProtocolVersion {
        return false
      }
      if !hasSourceId {
        return false
      }
      if !hasDestinationId {
        return false
      }
      if !hasNamespace {
        return false
      }
      if !hasPayloadType {
        return false
      }
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasProtocolVersion {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:protocolVersion.rawValue)
      }
      if hasSourceId {
        try codedOutputStream.writeString(fieldNumber: 2, value:sourceId)
      }
      if hasDestinationId {
        try codedOutputStream.writeString(fieldNumber: 3, value:destinationId)
      }
      if hasNamespace {
        try codedOutputStream.writeString(fieldNumber: 4, value:namespace)
      }
      if hasPayloadType {
        try codedOutputStream.writeEnum(fieldNumber: 5, value:payloadType.rawValue)
      }
      if hasPayloadUtf8 {
        try codedOutputStream.writeString(fieldNumber: 6, value:payloadUtf8)
      }
      if hasPayloadBinary {
        try codedOutputStream.writeData(fieldNumber: 7, value:payloadBinary)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasProtocolVersion) {
        serialize_size += protocolVersion.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasSourceId {
        serialize_size += sourceId.computeStringSize(fieldNumber: 2)
      }
      if hasDestinationId {
        serialize_size += destinationId.computeStringSize(fieldNumber: 3)
      }
      if hasNamespace {
        serialize_size += namespace.computeStringSize(fieldNumber: 4)
      }
      if (hasPayloadType) {
        serialize_size += payloadType.rawValue.computeEnumSize(fieldNumber: 5)
      }
      if hasPayloadUtf8 {
        serialize_size += payloadUtf8.computeStringSize(fieldNumber: 6)
      }
      if hasPayloadBinary {
        serialize_size += payloadBinary.computeDataSize(fieldNumber: 7)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Extensions.Api.CastChannel.CastMessage.Builder {
      return Extensions.Api.CastChannel.CastMessage.classBuilder() as! Extensions.Api.CastChannel.CastMessage.Builder
    }
    public func getBuilder() -> Extensions.Api.CastChannel.CastMessage.Builder {
      return classBuilder() as! Extensions.Api.CastChannel.CastMessage.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Extensions.Api.CastChannel.CastMessage.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Extensions.Api.CastChannel.CastMessage.Builder()
    }
    public func toBuilder() throws -> Extensions.Api.CastChannel.CastMessage.Builder {
      return try Extensions.Api.CastChannel.CastMessage.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Extensions.Api.CastChannel.CastMessage) throws -> Extensions.Api.CastChannel.CastMessage.Builder {
      return try Extensions.Api.CastChannel.CastMessage.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasProtocolVersion {
        jsonMap["protocolVersion"] = protocolVersion.toString()
      }
      if hasSourceId {
        jsonMap["sourceId"] = sourceId
      }
      if hasDestinationId {
        jsonMap["destinationId"] = destinationId
      }
      if hasNamespace {
        jsonMap["namespace"] = namespace
      }
      if hasPayloadType {
        jsonMap["payloadType"] = payloadType.toString()
      }
      if hasPayloadUtf8 {
        jsonMap["payloadUtf8"] = payloadUtf8
      }
      if hasPayloadBinary {
        jsonMap["payloadBinary"] = payloadBinary.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Extensions.Api.CastChannel.CastMessage {
      return try Extensions.Api.CastChannel.CastMessage.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Extensions.Api.CastChannel.CastMessage {
      return try Extensions.Api.CastChannel.CastMessage.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasProtocolVersion) {
        output += "\(indent) protocolVersion: \(protocolVersion.description)\n"
      }
      if hasSourceId {
        output += "\(indent) sourceId: \(sourceId) \n"
      }
      if hasDestinationId {
        output += "\(indent) destinationId: \(destinationId) \n"
      }
      if hasNamespace {
        output += "\(indent) namespace: \(namespace) \n"
      }
      if (hasPayloadType) {
        output += "\(indent) payloadType: \(payloadType.description)\n"
      }
      if hasPayloadUtf8 {
        output += "\(indent) payloadUtf8: \(payloadUtf8) \n"
      }
      if hasPayloadBinary {
        output += "\(indent) payloadBinary: \(payloadBinary) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasProtocolVersion {
               hashCode = (hashCode &* 31) &+ Int(protocolVersion.rawValue)
            }
            if hasSourceId {
               hashCode = (hashCode &* 31) &+ sourceId.hashValue
            }
            if hasDestinationId {
               hashCode = (hashCode &* 31) &+ destinationId.hashValue
            }
            if hasNamespace {
               hashCode = (hashCode &* 31) &+ namespace.hashValue
            }
            if hasPayloadType {
               hashCode = (hashCode &* 31) &+ Int(payloadType.rawValue)
            }
            if hasPayloadUtf8 {
               hashCode = (hashCode &* 31) &+ payloadUtf8.hashValue
            }
            if hasPayloadBinary {
               hashCode = (hashCode &* 31) &+ payloadBinary.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Extensions.Api.CastChannel.CastMessage"
    }
    override public func className() -> String {
        return "Extensions.Api.CastChannel.CastMessage"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Extensions.Api.CastChannel.CastMessage = Extensions.Api.CastChannel.CastMessage()
      public func getMessage() -> Extensions.Api.CastChannel.CastMessage {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasProtocolVersion:Bool{
            get {
                return builderResult.hasProtocolVersion
            }
        }
        public var protocolVersion:Extensions.Api.CastChannel.CastMessage.ProtocolVersion {
            get {
                return builderResult.protocolVersion
            }
            set (value) {
                builderResult.hasProtocolVersion = true
                builderResult.protocolVersion = value
            }
        }
      @discardableResult
        public func setProtocolVersion(_ value:Extensions.Api.CastChannel.CastMessage.ProtocolVersion) -> Extensions.Api.CastChannel.CastMessage.Builder {
          self.protocolVersion = value
          return self
        }
      @discardableResult
        public func clearProtocolVersion() -> Extensions.Api.CastChannel.CastMessage.Builder {
           builderResult.hasProtocolVersion = false
           builderResult.protocolVersion = .castv210
           return self
        }
      public var hasSourceId:Bool {
           get {
                return builderResult.hasSourceId
           }
      }
      public var sourceId:String {
           get {
                return builderResult.sourceId
           }
           set (value) {
               builderResult.hasSourceId = true
               builderResult.sourceId = value
           }
      }
      @discardableResult
      public func setSourceId(_ value:String) -> Extensions.Api.CastChannel.CastMessage.Builder {
        self.sourceId = value
        return self
      }
      @discardableResult
      public func clearSourceId() -> Extensions.Api.CastChannel.CastMessage.Builder{
           builderResult.hasSourceId = false
           builderResult.sourceId = ""
           return self
      }
      public var hasDestinationId:Bool {
           get {
                return builderResult.hasDestinationId
           }
      }
      public var destinationId:String {
           get {
                return builderResult.destinationId
           }
           set (value) {
               builderResult.hasDestinationId = true
               builderResult.destinationId = value
           }
      }
      @discardableResult
      public func setDestinationId(_ value:String) -> Extensions.Api.CastChannel.CastMessage.Builder {
        self.destinationId = value
        return self
      }
      @discardableResult
      public func clearDestinationId() -> Extensions.Api.CastChannel.CastMessage.Builder{
           builderResult.hasDestinationId = false
           builderResult.destinationId = ""
           return self
      }
      public var hasNamespace:Bool {
           get {
                return builderResult.hasNamespace
           }
      }
      public var namespace:String {
           get {
                return builderResult.namespace
           }
           set (value) {
               builderResult.hasNamespace = true
               builderResult.namespace = value
           }
      }
      @discardableResult
      public func setNamespace(_ value:String) -> Extensions.Api.CastChannel.CastMessage.Builder {
        self.namespace = value
        return self
      }
      @discardableResult
      public func clearNamespace() -> Extensions.Api.CastChannel.CastMessage.Builder{
           builderResult.hasNamespace = false
           builderResult.namespace = ""
           return self
      }
        public var hasPayloadType:Bool{
            get {
                return builderResult.hasPayloadType
            }
        }
        public var payloadType:Extensions.Api.CastChannel.CastMessage.PayloadType {
            get {
                return builderResult.payloadType
            }
            set (value) {
                builderResult.hasPayloadType = true
                builderResult.payloadType = value
            }
        }
      @discardableResult
        public func setPayloadType(_ value:Extensions.Api.CastChannel.CastMessage.PayloadType) -> Extensions.Api.CastChannel.CastMessage.Builder {
          self.payloadType = value
          return self
        }
      @discardableResult
        public func clearPayloadType() -> Extensions.Api.CastChannel.CastMessage.Builder {
           builderResult.hasPayloadType = false
           builderResult.payloadType = .`String`
           return self
        }
      public var hasPayloadUtf8:Bool {
           get {
                return builderResult.hasPayloadUtf8
           }
      }
      public var payloadUtf8:String {
           get {
                return builderResult.payloadUtf8
           }
           set (value) {
               builderResult.hasPayloadUtf8 = true
               builderResult.payloadUtf8 = value
           }
      }
      @discardableResult
      public func setPayloadUtf8(_ value:String) -> Extensions.Api.CastChannel.CastMessage.Builder {
        self.payloadUtf8 = value
        return self
      }
      @discardableResult
      public func clearPayloadUtf8() -> Extensions.Api.CastChannel.CastMessage.Builder{
           builderResult.hasPayloadUtf8 = false
           builderResult.payloadUtf8 = ""
           return self
      }
      public var hasPayloadBinary:Bool {
           get {
                return builderResult.hasPayloadBinary
           }
      }
      public var payloadBinary:Data {
           get {
                return builderResult.payloadBinary
           }
           set (value) {
               builderResult.hasPayloadBinary = true
               builderResult.payloadBinary = value
           }
      }
      @discardableResult
      public func setPayloadBinary(_ value:Data) -> Extensions.Api.CastChannel.CastMessage.Builder {
        self.payloadBinary = value
        return self
      }
      @discardableResult
      public func clearPayloadBinary() -> Extensions.Api.CastChannel.CastMessage.Builder{
           builderResult.hasPayloadBinary = false
           builderResult.payloadBinary = Data()
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Extensions.Api.CastChannel.CastMessage.Builder {
        builderResult = Extensions.Api.CastChannel.CastMessage()
        return self
      }
      override public func clone() throws -> Extensions.Api.CastChannel.CastMessage.Builder {
        return try Extensions.Api.CastChannel.CastMessage.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Extensions.Api.CastChannel.CastMessage {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Extensions.Api.CastChannel.CastMessage {
        let returnMe:Extensions.Api.CastChannel.CastMessage = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Extensions.Api.CastChannel.CastMessage) throws -> Extensions.Api.CastChannel.CastMessage.Builder {
        if other == Extensions.Api.CastChannel.CastMessage() {
         return self
        }
        if other.hasProtocolVersion {
             protocolVersion = other.protocolVersion
        }
        if other.hasSourceId {
             sourceId = other.sourceId
        }
        if other.hasDestinationId {
             destinationId = other.destinationId
        }
        if other.hasNamespace {
             namespace = other.namespace
        }
        if other.hasPayloadType {
             payloadType = other.payloadType
        }
        if other.hasPayloadUtf8 {
             payloadUtf8 = other.payloadUtf8
        }
        if other.hasPayloadBinary {
             payloadBinary = other.payloadBinary
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Extensions.Api.CastChannel.CastMessage.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Extensions.Api.CastChannel.CastMessage.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntprotocolVersion = try codedInputStream.readEnum()
            if let enumsprotocolVersion = Extensions.Api.CastChannel.CastMessage.ProtocolVersion(rawValue:valueIntprotocolVersion){
                 protocolVersion = enumsprotocolVersion
            } else {
                 try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntprotocolVersion))
            }

          case 18:
            sourceId = try codedInputStream.readString()

          case 26:
            destinationId = try codedInputStream.readString()

          case 34:
            namespace = try codedInputStream.readString()

          case 40:
            let valueIntpayloadType = try codedInputStream.readEnum()
            if let enumspayloadType = Extensions.Api.CastChannel.CastMessage.PayloadType(rawValue:valueIntpayloadType){
                 payloadType = enumspayloadType
            } else {
                 try unknownFieldsBuilder.mergeVarintField(fieldNumber: 5, value:Int64(valueIntpayloadType))
            }

          case 50:
            payloadUtf8 = try codedInputStream.readString()

          case 58:
            payloadBinary = try codedInputStream.readData()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Extensions.Api.CastChannel.CastMessage.Builder {
        let resultDecodedBuilder = Extensions.Api.CastChannel.CastMessage.Builder()
        if let jsonValueProtocolVersion = jsonMap["protocolVersion"] as? String {
          resultDecodedBuilder.protocolVersion = try Extensions.Api.CastChannel.CastMessage.ProtocolVersion.fromString(str: jsonValueProtocolVersion)
        }
        if let jsonValueSourceId = jsonMap["sourceId"] as? String {
          resultDecodedBuilder.sourceId = jsonValueSourceId
        }
        if let jsonValueDestinationId = jsonMap["destinationId"] as? String {
          resultDecodedBuilder.destinationId = jsonValueDestinationId
        }
        if let jsonValueNamespace = jsonMap["namespace"] as? String {
          resultDecodedBuilder.namespace = jsonValueNamespace
        }
        if let jsonValuePayloadType = jsonMap["payloadType"] as? String {
          resultDecodedBuilder.payloadType = try Extensions.Api.CastChannel.CastMessage.PayloadType.fromString(str: jsonValuePayloadType)
        }
        if let jsonValuePayloadUtf8 = jsonMap["payloadUtf8"] as? String {
          resultDecodedBuilder.payloadUtf8 = jsonValuePayloadUtf8
        }
        if let jsonValuePayloadBinary = jsonMap["payloadBinary"] as? String {
          resultDecodedBuilder.payloadBinary = Data(base64Encoded:jsonValuePayloadBinary, options: Data.Base64DecodingOptions(rawValue:0))!
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Extensions.Api.CastChannel.CastMessage.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Extensions.Api.CastChannel.CastMessage.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  // Messages for authentication protocol between a sender and a receiver.
  final public class AuthChallenge : GeneratedMessage {

    public static func == (lhs: Extensions.Api.CastChannel.AuthChallenge, rhs: Extensions.Api.CastChannel.AuthChallenge) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Extensions.Api.CastChannel.AuthChallenge.Builder {
      return Extensions.Api.CastChannel.AuthChallenge.classBuilder() as! Extensions.Api.CastChannel.AuthChallenge.Builder
    }
    public func getBuilder() -> Extensions.Api.CastChannel.AuthChallenge.Builder {
      return classBuilder() as! Extensions.Api.CastChannel.AuthChallenge.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Extensions.Api.CastChannel.AuthChallenge.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Extensions.Api.CastChannel.AuthChallenge.Builder()
    }
    public func toBuilder() throws -> Extensions.Api.CastChannel.AuthChallenge.Builder {
      return try Extensions.Api.CastChannel.AuthChallenge.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Extensions.Api.CastChannel.AuthChallenge) throws -> Extensions.Api.CastChannel.AuthChallenge.Builder {
      return try Extensions.Api.CastChannel.AuthChallenge.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Extensions.Api.CastChannel.AuthChallenge {
      return try Extensions.Api.CastChannel.AuthChallenge.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Extensions.Api.CastChannel.AuthChallenge {
      return try Extensions.Api.CastChannel.AuthChallenge.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Extensions.Api.CastChannel.AuthChallenge"
    }
    override public func className() -> String {
        return "Extensions.Api.CastChannel.AuthChallenge"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Extensions.Api.CastChannel.AuthChallenge = Extensions.Api.CastChannel.AuthChallenge()
      public func getMessage() -> Extensions.Api.CastChannel.AuthChallenge {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Extensions.Api.CastChannel.AuthChallenge.Builder {
        builderResult = Extensions.Api.CastChannel.AuthChallenge()
        return self
      }
      override public func clone() throws -> Extensions.Api.CastChannel.AuthChallenge.Builder {
        return try Extensions.Api.CastChannel.AuthChallenge.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Extensions.Api.CastChannel.AuthChallenge {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Extensions.Api.CastChannel.AuthChallenge {
        let returnMe:Extensions.Api.CastChannel.AuthChallenge = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Extensions.Api.CastChannel.AuthChallenge) throws -> Extensions.Api.CastChannel.AuthChallenge.Builder {
        if other == Extensions.Api.CastChannel.AuthChallenge() {
         return self
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Extensions.Api.CastChannel.AuthChallenge.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Extensions.Api.CastChannel.AuthChallenge.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Extensions.Api.CastChannel.AuthChallenge.Builder {
        let resultDecodedBuilder = Extensions.Api.CastChannel.AuthChallenge.Builder()
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Extensions.Api.CastChannel.AuthChallenge.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Extensions.Api.CastChannel.AuthChallenge.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class AuthResponse : GeneratedMessage {

    public static func == (lhs: Extensions.Api.CastChannel.AuthResponse, rhs: Extensions.Api.CastChannel.AuthResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasSignature == rhs.hasSignature) && (!lhs.hasSignature || lhs.signature == rhs.signature)
      fieldCheck = fieldCheck && (lhs.hasClientAuthCertificate == rhs.hasClientAuthCertificate) && (!lhs.hasClientAuthCertificate || lhs.clientAuthCertificate == rhs.clientAuthCertificate)
      fieldCheck = fieldCheck && (lhs.clientCa == rhs.clientCa)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var signature:Data = Data()
    public fileprivate(set) var hasSignature:Bool = false

    public fileprivate(set) var clientAuthCertificate:Data = Data()
    public fileprivate(set) var hasClientAuthCertificate:Bool = false

    public fileprivate(set) var clientCa:Array<Data> = Array<Data>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if !hasSignature {
        return false
      }
      if !hasClientAuthCertificate {
        return false
      }
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasSignature {
        try codedOutputStream.writeData(fieldNumber: 1, value:signature)
      }
      if hasClientAuthCertificate {
        try codedOutputStream.writeData(fieldNumber: 2, value:clientAuthCertificate)
      }
      if !clientCa.isEmpty {
        for oneValueclientCa in clientCa {
          try codedOutputStream.writeData(fieldNumber: 3, value:oneValueclientCa)
        }
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasSignature {
        serialize_size += signature.computeDataSize(fieldNumber: 1)
      }
      if hasClientAuthCertificate {
        serialize_size += clientAuthCertificate.computeDataSize(fieldNumber: 2)
      }
      var dataSizeClientCa:Int32 = 0
      for oneValueclientCa in clientCa {
          dataSizeClientCa += oneValueclientCa.computeDataSizeNoTag()
      }
      serialize_size += dataSizeClientCa
      serialize_size += 1 * Int32(clientCa.count)
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Extensions.Api.CastChannel.AuthResponse.Builder {
      return Extensions.Api.CastChannel.AuthResponse.classBuilder() as! Extensions.Api.CastChannel.AuthResponse.Builder
    }
    public func getBuilder() -> Extensions.Api.CastChannel.AuthResponse.Builder {
      return classBuilder() as! Extensions.Api.CastChannel.AuthResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Extensions.Api.CastChannel.AuthResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Extensions.Api.CastChannel.AuthResponse.Builder()
    }
    public func toBuilder() throws -> Extensions.Api.CastChannel.AuthResponse.Builder {
      return try Extensions.Api.CastChannel.AuthResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Extensions.Api.CastChannel.AuthResponse) throws -> Extensions.Api.CastChannel.AuthResponse.Builder {
      return try Extensions.Api.CastChannel.AuthResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasSignature {
        jsonMap["signature"] = signature.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
      }
      if hasClientAuthCertificate {
        jsonMap["clientAuthCertificate"] = clientAuthCertificate.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
      }
      if !clientCa.isEmpty {
        var jsonArrayClientCa:Array<String> = []
          for oneValueClientCa in clientCa {
            jsonArrayClientCa.append(oneValueClientCa.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0)))
          }
        jsonMap["clientCa"] = jsonArrayClientCa
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Extensions.Api.CastChannel.AuthResponse {
      return try Extensions.Api.CastChannel.AuthResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Extensions.Api.CastChannel.AuthResponse {
      return try Extensions.Api.CastChannel.AuthResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasSignature {
        output += "\(indent) signature: \(signature) \n"
      }
      if hasClientAuthCertificate {
        output += "\(indent) clientAuthCertificate: \(clientAuthCertificate) \n"
      }
      var clientCaElementIndex:Int = 0
      for oneValueClientCa in clientCa  {
          output += "\(indent) clientCa[\(clientCaElementIndex)]: \(oneValueClientCa)\n"
          clientCaElementIndex += 1
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSignature {
               hashCode = (hashCode &* 31) &+ signature.hashValue
            }
            if hasClientAuthCertificate {
               hashCode = (hashCode &* 31) &+ clientAuthCertificate.hashValue
            }
            for oneValueClientCa in clientCa {
                hashCode = (hashCode &* 31) &+ oneValueClientCa.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Extensions.Api.CastChannel.AuthResponse"
    }
    override public func className() -> String {
        return "Extensions.Api.CastChannel.AuthResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Extensions.Api.CastChannel.AuthResponse = Extensions.Api.CastChannel.AuthResponse()
      public func getMessage() -> Extensions.Api.CastChannel.AuthResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasSignature:Bool {
           get {
                return builderResult.hasSignature
           }
      }
      public var signature:Data {
           get {
                return builderResult.signature
           }
           set (value) {
               builderResult.hasSignature = true
               builderResult.signature = value
           }
      }
      @discardableResult
      public func setSignature(_ value:Data) -> Extensions.Api.CastChannel.AuthResponse.Builder {
        self.signature = value
        return self
      }
      @discardableResult
      public func clearSignature() -> Extensions.Api.CastChannel.AuthResponse.Builder{
           builderResult.hasSignature = false
           builderResult.signature = Data()
           return self
      }
      public var hasClientAuthCertificate:Bool {
           get {
                return builderResult.hasClientAuthCertificate
           }
      }
      public var clientAuthCertificate:Data {
           get {
                return builderResult.clientAuthCertificate
           }
           set (value) {
               builderResult.hasClientAuthCertificate = true
               builderResult.clientAuthCertificate = value
           }
      }
      @discardableResult
      public func setClientAuthCertificate(_ value:Data) -> Extensions.Api.CastChannel.AuthResponse.Builder {
        self.clientAuthCertificate = value
        return self
      }
      @discardableResult
      public func clearClientAuthCertificate() -> Extensions.Api.CastChannel.AuthResponse.Builder{
           builderResult.hasClientAuthCertificate = false
           builderResult.clientAuthCertificate = Data()
           return self
      }
      public var clientCa:Array<Data> {
           get {
               return builderResult.clientCa
           }
           set (array) {
               builderResult.clientCa = array
           }
      }
      @discardableResult
      public func setClientCa(_ value:Array<Data>) -> Extensions.Api.CastChannel.AuthResponse.Builder {
        self.clientCa = value
        return self
      }
      @discardableResult
      public func clearClientCa() -> Extensions.Api.CastChannel.AuthResponse.Builder {
         builderResult.clientCa.removeAll(keepingCapacity: false)
         return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Extensions.Api.CastChannel.AuthResponse.Builder {
        builderResult = Extensions.Api.CastChannel.AuthResponse()
        return self
      }
      override public func clone() throws -> Extensions.Api.CastChannel.AuthResponse.Builder {
        return try Extensions.Api.CastChannel.AuthResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Extensions.Api.CastChannel.AuthResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Extensions.Api.CastChannel.AuthResponse {
        let returnMe:Extensions.Api.CastChannel.AuthResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Extensions.Api.CastChannel.AuthResponse) throws -> Extensions.Api.CastChannel.AuthResponse.Builder {
        if other == Extensions.Api.CastChannel.AuthResponse() {
         return self
        }
        if other.hasSignature {
             signature = other.signature
        }
        if other.hasClientAuthCertificate {
             clientAuthCertificate = other.clientAuthCertificate
        }
        if !other.clientCa.isEmpty {
            builderResult.clientCa += other.clientCa
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Extensions.Api.CastChannel.AuthResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Extensions.Api.CastChannel.AuthResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            signature = try codedInputStream.readData()

          case 18:
            clientAuthCertificate = try codedInputStream.readData()

          case 26:
            clientCa += [try codedInputStream.readData()]

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Extensions.Api.CastChannel.AuthResponse.Builder {
        let resultDecodedBuilder = Extensions.Api.CastChannel.AuthResponse.Builder()
        if let jsonValueSignature = jsonMap["signature"] as? String {
          resultDecodedBuilder.signature = Data(base64Encoded:jsonValueSignature, options: Data.Base64DecodingOptions(rawValue:0))!
        }
        if let jsonValueClientAuthCertificate = jsonMap["clientAuthCertificate"] as? String {
          resultDecodedBuilder.clientAuthCertificate = Data(base64Encoded:jsonValueClientAuthCertificate, options: Data.Base64DecodingOptions(rawValue:0))!
        }
        if let jsonValueClientCa = jsonMap["clientCa"] as? Array<String> {
          var jsonArrayClientCa:Array<Data> = []
          for oneValueClientCa in jsonValueClientCa {
            jsonArrayClientCa.append(Data(base64Encoded:oneValueClientCa, options: Data.Base64DecodingOptions(rawValue:0))!)
          }
          resultDecodedBuilder.clientCa = jsonArrayClientCa
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Extensions.Api.CastChannel.AuthResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Extensions.Api.CastChannel.AuthResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class AuthError : GeneratedMessage {

    public static func == (lhs: Extensions.Api.CastChannel.AuthError, rhs: Extensions.Api.CastChannel.AuthError) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasErrorType == rhs.hasErrorType) && (!lhs.hasErrorType || lhs.errorType == rhs.errorType)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum ErrorType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case internalError = 0

        // The underlying connection is not TLS
        case noTls = 1
        public func toString() -> String {
          switch self {
          case .internalError: return "INTERNAL_ERROR"
          case .noTls: return "NO_TLS"
          }
        }
        public static func fromString(str:String) throws -> Extensions.Api.CastChannel.AuthError.ErrorType {
          switch str {
          case "INTERNAL_ERROR":  return .internalError
          case "NO_TLS":  return .noTls
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .internalError: return ".internalError"
          case .noTls: return ".noTls"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var errorType:Extensions.Api.CastChannel.AuthError.ErrorType = Extensions.Api.CastChannel.AuthError.ErrorType.internalError
    public fileprivate(set) var hasErrorType:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if !hasErrorType {
        return false
      }
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasErrorType {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:errorType.rawValue)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasErrorType) {
        serialize_size += errorType.rawValue.computeEnumSize(fieldNumber: 1)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Extensions.Api.CastChannel.AuthError.Builder {
      return Extensions.Api.CastChannel.AuthError.classBuilder() as! Extensions.Api.CastChannel.AuthError.Builder
    }
    public func getBuilder() -> Extensions.Api.CastChannel.AuthError.Builder {
      return classBuilder() as! Extensions.Api.CastChannel.AuthError.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Extensions.Api.CastChannel.AuthError.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Extensions.Api.CastChannel.AuthError.Builder()
    }
    public func toBuilder() throws -> Extensions.Api.CastChannel.AuthError.Builder {
      return try Extensions.Api.CastChannel.AuthError.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Extensions.Api.CastChannel.AuthError) throws -> Extensions.Api.CastChannel.AuthError.Builder {
      return try Extensions.Api.CastChannel.AuthError.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasErrorType {
        jsonMap["errorType"] = errorType.toString()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Extensions.Api.CastChannel.AuthError {
      return try Extensions.Api.CastChannel.AuthError.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Extensions.Api.CastChannel.AuthError {
      return try Extensions.Api.CastChannel.AuthError.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasErrorType) {
        output += "\(indent) errorType: \(errorType.description)\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasErrorType {
               hashCode = (hashCode &* 31) &+ Int(errorType.rawValue)
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Extensions.Api.CastChannel.AuthError"
    }
    override public func className() -> String {
        return "Extensions.Api.CastChannel.AuthError"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Extensions.Api.CastChannel.AuthError = Extensions.Api.CastChannel.AuthError()
      public func getMessage() -> Extensions.Api.CastChannel.AuthError {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasErrorType:Bool{
            get {
                return builderResult.hasErrorType
            }
        }
        public var errorType:Extensions.Api.CastChannel.AuthError.ErrorType {
            get {
                return builderResult.errorType
            }
            set (value) {
                builderResult.hasErrorType = true
                builderResult.errorType = value
            }
        }
      @discardableResult
        public func setErrorType(_ value:Extensions.Api.CastChannel.AuthError.ErrorType) -> Extensions.Api.CastChannel.AuthError.Builder {
          self.errorType = value
          return self
        }
      @discardableResult
        public func clearErrorType() -> Extensions.Api.CastChannel.AuthError.Builder {
           builderResult.hasErrorType = false
           builderResult.errorType = .internalError
           return self
        }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Extensions.Api.CastChannel.AuthError.Builder {
        builderResult = Extensions.Api.CastChannel.AuthError()
        return self
      }
      override public func clone() throws -> Extensions.Api.CastChannel.AuthError.Builder {
        return try Extensions.Api.CastChannel.AuthError.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Extensions.Api.CastChannel.AuthError {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Extensions.Api.CastChannel.AuthError {
        let returnMe:Extensions.Api.CastChannel.AuthError = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Extensions.Api.CastChannel.AuthError) throws -> Extensions.Api.CastChannel.AuthError.Builder {
        if other == Extensions.Api.CastChannel.AuthError() {
         return self
        }
        if other.hasErrorType {
             errorType = other.errorType
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Extensions.Api.CastChannel.AuthError.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Extensions.Api.CastChannel.AuthError.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueInterrorType = try codedInputStream.readEnum()
            if let enumserrorType = Extensions.Api.CastChannel.AuthError.ErrorType(rawValue:valueInterrorType){
                 errorType = enumserrorType
            } else {
                 try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueInterrorType))
            }

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Extensions.Api.CastChannel.AuthError.Builder {
        let resultDecodedBuilder = Extensions.Api.CastChannel.AuthError.Builder()
        if let jsonValueErrorType = jsonMap["errorType"] as? String {
          resultDecodedBuilder.errorType = try Extensions.Api.CastChannel.AuthError.ErrorType.fromString(str: jsonValueErrorType)
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Extensions.Api.CastChannel.AuthError.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Extensions.Api.CastChannel.AuthError.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class DeviceAuthMessage : GeneratedMessage {

    public static func == (lhs: Extensions.Api.CastChannel.DeviceAuthMessage, rhs: Extensions.Api.CastChannel.DeviceAuthMessage) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasChallenge == rhs.hasChallenge) && (!lhs.hasChallenge || lhs.challenge == rhs.challenge)
      fieldCheck = fieldCheck && (lhs.hasResponse == rhs.hasResponse) && (!lhs.hasResponse || lhs.response == rhs.response)
      fieldCheck = fieldCheck && (lhs.hasError == rhs.hasError) && (!lhs.hasError || lhs.error == rhs.error)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var challenge:Extensions.Api.CastChannel.AuthChallenge!
    public fileprivate(set) var hasChallenge:Bool = false
    public fileprivate(set) var response:Extensions.Api.CastChannel.AuthResponse!
    public fileprivate(set) var hasResponse:Bool = false
    public fileprivate(set) var error:Extensions.Api.CastChannel.AuthError!
    public fileprivate(set) var hasError:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if hasResponse {
       if !response.isInitialized() {
         return false
       }
      }
      if hasError {
       if !error.isInitialized() {
         return false
       }
      }
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasChallenge {
        try codedOutputStream.writeMessage(fieldNumber: 1, value:challenge)
      }
      if hasResponse {
        try codedOutputStream.writeMessage(fieldNumber: 2, value:response)
      }
      if hasError {
        try codedOutputStream.writeMessage(fieldNumber: 3, value:error)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasChallenge {
          if let varSizechallenge = challenge?.computeMessageSize(fieldNumber: 1) {
              serialize_size += varSizechallenge
          }
      }
      if hasResponse {
          if let varSizeresponse = response?.computeMessageSize(fieldNumber: 2) {
              serialize_size += varSizeresponse
          }
      }
      if hasError {
          if let varSizeerror = error?.computeMessageSize(fieldNumber: 3) {
              serialize_size += varSizeerror
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Extensions.Api.CastChannel.DeviceAuthMessage.Builder {
      return Extensions.Api.CastChannel.DeviceAuthMessage.classBuilder() as! Extensions.Api.CastChannel.DeviceAuthMessage.Builder
    }
    public func getBuilder() -> Extensions.Api.CastChannel.DeviceAuthMessage.Builder {
      return classBuilder() as! Extensions.Api.CastChannel.DeviceAuthMessage.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Extensions.Api.CastChannel.DeviceAuthMessage.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Extensions.Api.CastChannel.DeviceAuthMessage.Builder()
    }
    public func toBuilder() throws -> Extensions.Api.CastChannel.DeviceAuthMessage.Builder {
      return try Extensions.Api.CastChannel.DeviceAuthMessage.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Extensions.Api.CastChannel.DeviceAuthMessage) throws -> Extensions.Api.CastChannel.DeviceAuthMessage.Builder {
      return try Extensions.Api.CastChannel.DeviceAuthMessage.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasChallenge {
        jsonMap["challenge"] = try challenge.encode()
      }
      if hasResponse {
        jsonMap["response"] = try response.encode()
      }
      if hasError {
        jsonMap["error"] = try error.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Extensions.Api.CastChannel.DeviceAuthMessage {
      return try Extensions.Api.CastChannel.DeviceAuthMessage.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Extensions.Api.CastChannel.DeviceAuthMessage {
      return try Extensions.Api.CastChannel.DeviceAuthMessage.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasChallenge {
        output += "\(indent) challenge {\n"
        if let outDescChallenge = challenge {
          output += try outDescChallenge.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasResponse {
        output += "\(indent) response {\n"
        if let outDescResponse = response {
          output += try outDescResponse.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasError {
        output += "\(indent) error {\n"
        if let outDescError = error {
          output += try outDescError.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasChallenge {
                if let hashValuechallenge = challenge?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuechallenge
                }
            }
            if hasResponse {
                if let hashValueresponse = response?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueresponse
                }
            }
            if hasError {
                if let hashValueerror = error?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueerror
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Extensions.Api.CastChannel.DeviceAuthMessage"
    }
    override public func className() -> String {
        return "Extensions.Api.CastChannel.DeviceAuthMessage"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Extensions.Api.CastChannel.DeviceAuthMessage = Extensions.Api.CastChannel.DeviceAuthMessage()
      public func getMessage() -> Extensions.Api.CastChannel.DeviceAuthMessage {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasChallenge:Bool {
           get {
               return builderResult.hasChallenge
           }
      }
      public var challenge:Extensions.Api.CastChannel.AuthChallenge! {
           get {
               if challengeBuilder_ != nil {
                  builderResult.challenge = challengeBuilder_.getMessage()
               }
               return builderResult.challenge
           }
           set (value) {
               builderResult.hasChallenge = true
               builderResult.challenge = value
           }
      }
      fileprivate var challengeBuilder_:Extensions.Api.CastChannel.AuthChallenge.Builder! {
           didSet {
              builderResult.hasChallenge = true
           }
      }
      public func getChallengeBuilder() -> Extensions.Api.CastChannel.AuthChallenge.Builder {
        if challengeBuilder_ == nil {
           challengeBuilder_ = Extensions.Api.CastChannel.AuthChallenge.Builder()
           builderResult.challenge = challengeBuilder_.getMessage()
           if challenge != nil {
              try! challengeBuilder_.mergeFrom(other: challenge)
           }
        }
        return challengeBuilder_
      }
      @discardableResult
      public func setChallenge(_ value:Extensions.Api.CastChannel.AuthChallenge!) -> Extensions.Api.CastChannel.DeviceAuthMessage.Builder {
        self.challenge = value
        return self
      }
      @discardableResult
      public func mergeChallenge(value:Extensions.Api.CastChannel.AuthChallenge) throws -> Extensions.Api.CastChannel.DeviceAuthMessage.Builder {
        if builderResult.hasChallenge {
          builderResult.challenge = try Extensions.Api.CastChannel.AuthChallenge.builderWithPrototype(prototype:builderResult.challenge).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.challenge = value
        }
        builderResult.hasChallenge = true
        return self
      }
      @discardableResult
      public func clearChallenge() -> Extensions.Api.CastChannel.DeviceAuthMessage.Builder {
        challengeBuilder_ = nil
        builderResult.hasChallenge = false
        builderResult.challenge = nil
        return self
      }
      public var hasResponse:Bool {
           get {
               return builderResult.hasResponse
           }
      }
      public var response:Extensions.Api.CastChannel.AuthResponse! {
           get {
               if responseBuilder_ != nil {
                  builderResult.response = responseBuilder_.getMessage()
               }
               return builderResult.response
           }
           set (value) {
               builderResult.hasResponse = true
               builderResult.response = value
           }
      }
      fileprivate var responseBuilder_:Extensions.Api.CastChannel.AuthResponse.Builder! {
           didSet {
              builderResult.hasResponse = true
           }
      }
      public func getResponseBuilder() -> Extensions.Api.CastChannel.AuthResponse.Builder {
        if responseBuilder_ == nil {
           responseBuilder_ = Extensions.Api.CastChannel.AuthResponse.Builder()
           builderResult.response = responseBuilder_.getMessage()
           if response != nil {
              try! responseBuilder_.mergeFrom(other: response)
           }
        }
        return responseBuilder_
      }
      @discardableResult
      public func setResponse(_ value:Extensions.Api.CastChannel.AuthResponse!) -> Extensions.Api.CastChannel.DeviceAuthMessage.Builder {
        self.response = value
        return self
      }
      @discardableResult
      public func mergeResponse(value:Extensions.Api.CastChannel.AuthResponse) throws -> Extensions.Api.CastChannel.DeviceAuthMessage.Builder {
        if builderResult.hasResponse {
          builderResult.response = try Extensions.Api.CastChannel.AuthResponse.builderWithPrototype(prototype:builderResult.response).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.response = value
        }
        builderResult.hasResponse = true
        return self
      }
      @discardableResult
      public func clearResponse() -> Extensions.Api.CastChannel.DeviceAuthMessage.Builder {
        responseBuilder_ = nil
        builderResult.hasResponse = false
        builderResult.response = nil
        return self
      }
      public var hasError:Bool {
           get {
               return builderResult.hasError
           }
      }
      public var error:Extensions.Api.CastChannel.AuthError! {
           get {
               if errorBuilder_ != nil {
                  builderResult.error = errorBuilder_.getMessage()
               }
               return builderResult.error
           }
           set (value) {
               builderResult.hasError = true
               builderResult.error = value
           }
      }
      fileprivate var errorBuilder_:Extensions.Api.CastChannel.AuthError.Builder! {
           didSet {
              builderResult.hasError = true
           }
      }
      public func getErrorBuilder() -> Extensions.Api.CastChannel.AuthError.Builder {
        if errorBuilder_ == nil {
           errorBuilder_ = Extensions.Api.CastChannel.AuthError.Builder()
           builderResult.error = errorBuilder_.getMessage()
           if error != nil {
              try! errorBuilder_.mergeFrom(other: error)
           }
        }
        return errorBuilder_
      }
      @discardableResult
      public func setError(_ value:Extensions.Api.CastChannel.AuthError!) -> Extensions.Api.CastChannel.DeviceAuthMessage.Builder {
        self.error = value
        return self
      }
      @discardableResult
      public func mergeError(value:Extensions.Api.CastChannel.AuthError) throws -> Extensions.Api.CastChannel.DeviceAuthMessage.Builder {
        if builderResult.hasError {
          builderResult.error = try Extensions.Api.CastChannel.AuthError.builderWithPrototype(prototype:builderResult.error).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.error = value
        }
        builderResult.hasError = true
        return self
      }
      @discardableResult
      public func clearError() -> Extensions.Api.CastChannel.DeviceAuthMessage.Builder {
        errorBuilder_ = nil
        builderResult.hasError = false
        builderResult.error = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Extensions.Api.CastChannel.DeviceAuthMessage.Builder {
        builderResult = Extensions.Api.CastChannel.DeviceAuthMessage()
        return self
      }
      override public func clone() throws -> Extensions.Api.CastChannel.DeviceAuthMessage.Builder {
        return try Extensions.Api.CastChannel.DeviceAuthMessage.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Extensions.Api.CastChannel.DeviceAuthMessage {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Extensions.Api.CastChannel.DeviceAuthMessage {
        let returnMe:Extensions.Api.CastChannel.DeviceAuthMessage = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Extensions.Api.CastChannel.DeviceAuthMessage) throws -> Extensions.Api.CastChannel.DeviceAuthMessage.Builder {
        if other == Extensions.Api.CastChannel.DeviceAuthMessage() {
         return self
        }
        if (other.hasChallenge) {
            try mergeChallenge(value: other.challenge)
        }
        if (other.hasResponse) {
            try mergeResponse(value: other.response)
        }
        if (other.hasError) {
            try mergeError(value: other.error)
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Extensions.Api.CastChannel.DeviceAuthMessage.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Extensions.Api.CastChannel.DeviceAuthMessage.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            let subBuilder:Extensions.Api.CastChannel.AuthChallenge.Builder = Extensions.Api.CastChannel.AuthChallenge.Builder()
            if hasChallenge {
              try subBuilder.mergeFrom(other: challenge)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            challenge = subBuilder.buildPartial()

          case 18:
            let subBuilder:Extensions.Api.CastChannel.AuthResponse.Builder = Extensions.Api.CastChannel.AuthResponse.Builder()
            if hasResponse {
              try subBuilder.mergeFrom(other: response)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            response = subBuilder.buildPartial()

          case 26:
            let subBuilder:Extensions.Api.CastChannel.AuthError.Builder = Extensions.Api.CastChannel.AuthError.Builder()
            if hasError {
              try subBuilder.mergeFrom(other: error)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            error = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Extensions.Api.CastChannel.DeviceAuthMessage.Builder {
        let resultDecodedBuilder = Extensions.Api.CastChannel.DeviceAuthMessage.Builder()
        if let jsonValueChallenge = jsonMap["challenge"] as? Dictionary<String,Any> {
          resultDecodedBuilder.challenge = try Extensions.Api.CastChannel.AuthChallenge.Builder.decodeToBuilder(jsonMap:jsonValueChallenge).build()

        }
        if let jsonValueResponse = jsonMap["response"] as? Dictionary<String,Any> {
          resultDecodedBuilder.response = try Extensions.Api.CastChannel.AuthResponse.Builder.decodeToBuilder(jsonMap:jsonValueResponse).build()

        }
        if let jsonValueError = jsonMap["error"] as? Dictionary<String,Any> {
          resultDecodedBuilder.error = try Extensions.Api.CastChannel.AuthError.Builder.decodeToBuilder(jsonMap:jsonValueError).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Extensions.Api.CastChannel.DeviceAuthMessage.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Extensions.Api.CastChannel.DeviceAuthMessage.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

}
extension Extensions.Api.CastChannel.CastMessage: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Extensions.Api.CastChannel.CastMessage> {
    var mergedArray = Array<Extensions.Api.CastChannel.CastMessage>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Extensions.Api.CastChannel.CastMessage? {
    return try Extensions.Api.CastChannel.CastMessage.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Extensions.Api.CastChannel.CastMessage {
    return try Extensions.Api.CastChannel.CastMessage.Builder().mergeFrom(data: data, extensionRegistry:Extensions.Api.CastChannel.CastChannelRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Extensions.Api.CastChannel.CastMessage {
    return try Extensions.Api.CastChannel.CastMessage.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Extensions.Api.CastChannel.CastMessage {
    return try Extensions.Api.CastChannel.CastMessage.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Extensions.Api.CastChannel.CastMessage {
    return try Extensions.Api.CastChannel.CastMessage.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Extensions.Api.CastChannel.CastMessage {
    return try Extensions.Api.CastChannel.CastMessage.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Extensions.Api.CastChannel.CastMessage {
    return try Extensions.Api.CastChannel.CastMessage.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Extensions.Api.CastChannel.AuthChallenge: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Extensions.Api.CastChannel.AuthChallenge> {
    var mergedArray = Array<Extensions.Api.CastChannel.AuthChallenge>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Extensions.Api.CastChannel.AuthChallenge? {
    return try Extensions.Api.CastChannel.AuthChallenge.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Extensions.Api.CastChannel.AuthChallenge {
    return try Extensions.Api.CastChannel.AuthChallenge.Builder().mergeFrom(data: data, extensionRegistry:Extensions.Api.CastChannel.CastChannelRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Extensions.Api.CastChannel.AuthChallenge {
    return try Extensions.Api.CastChannel.AuthChallenge.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Extensions.Api.CastChannel.AuthChallenge {
    return try Extensions.Api.CastChannel.AuthChallenge.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Extensions.Api.CastChannel.AuthChallenge {
    return try Extensions.Api.CastChannel.AuthChallenge.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Extensions.Api.CastChannel.AuthChallenge {
    return try Extensions.Api.CastChannel.AuthChallenge.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Extensions.Api.CastChannel.AuthChallenge {
    return try Extensions.Api.CastChannel.AuthChallenge.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Extensions.Api.CastChannel.AuthResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Extensions.Api.CastChannel.AuthResponse> {
    var mergedArray = Array<Extensions.Api.CastChannel.AuthResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Extensions.Api.CastChannel.AuthResponse? {
    return try Extensions.Api.CastChannel.AuthResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Extensions.Api.CastChannel.AuthResponse {
    return try Extensions.Api.CastChannel.AuthResponse.Builder().mergeFrom(data: data, extensionRegistry:Extensions.Api.CastChannel.CastChannelRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Extensions.Api.CastChannel.AuthResponse {
    return try Extensions.Api.CastChannel.AuthResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Extensions.Api.CastChannel.AuthResponse {
    return try Extensions.Api.CastChannel.AuthResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Extensions.Api.CastChannel.AuthResponse {
    return try Extensions.Api.CastChannel.AuthResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Extensions.Api.CastChannel.AuthResponse {
    return try Extensions.Api.CastChannel.AuthResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Extensions.Api.CastChannel.AuthResponse {
    return try Extensions.Api.CastChannel.AuthResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Extensions.Api.CastChannel.AuthError: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Extensions.Api.CastChannel.AuthError> {
    var mergedArray = Array<Extensions.Api.CastChannel.AuthError>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Extensions.Api.CastChannel.AuthError? {
    return try Extensions.Api.CastChannel.AuthError.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Extensions.Api.CastChannel.AuthError {
    return try Extensions.Api.CastChannel.AuthError.Builder().mergeFrom(data: data, extensionRegistry:Extensions.Api.CastChannel.CastChannelRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Extensions.Api.CastChannel.AuthError {
    return try Extensions.Api.CastChannel.AuthError.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Extensions.Api.CastChannel.AuthError {
    return try Extensions.Api.CastChannel.AuthError.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Extensions.Api.CastChannel.AuthError {
    return try Extensions.Api.CastChannel.AuthError.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Extensions.Api.CastChannel.AuthError {
    return try Extensions.Api.CastChannel.AuthError.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Extensions.Api.CastChannel.AuthError {
    return try Extensions.Api.CastChannel.AuthError.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Extensions.Api.CastChannel.DeviceAuthMessage: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Extensions.Api.CastChannel.DeviceAuthMessage> {
    var mergedArray = Array<Extensions.Api.CastChannel.DeviceAuthMessage>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Extensions.Api.CastChannel.DeviceAuthMessage? {
    return try Extensions.Api.CastChannel.DeviceAuthMessage.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Extensions.Api.CastChannel.DeviceAuthMessage {
    return try Extensions.Api.CastChannel.DeviceAuthMessage.Builder().mergeFrom(data: data, extensionRegistry:Extensions.Api.CastChannel.CastChannelRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Extensions.Api.CastChannel.DeviceAuthMessage {
    return try Extensions.Api.CastChannel.DeviceAuthMessage.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Extensions.Api.CastChannel.DeviceAuthMessage {
    return try Extensions.Api.CastChannel.DeviceAuthMessage.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Extensions.Api.CastChannel.DeviceAuthMessage {
    return try Extensions.Api.CastChannel.DeviceAuthMessage.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Extensions.Api.CastChannel.DeviceAuthMessage {
    return try Extensions.Api.CastChannel.DeviceAuthMessage.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Extensions.Api.CastChannel.DeviceAuthMessage {
    return try Extensions.Api.CastChannel.DeviceAuthMessage.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}

// @@protoc_insertion_point(global_scope)
